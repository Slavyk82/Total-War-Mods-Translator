import 'dart:io' as io;
import '../../models/common/result.dart';
import 'models/localization_file.dart';
import 'models/localization_entry.dart';
import 'models/file_exceptions.dart';
import 'i_localization_parser.dart';

/// Parser for TSV localization files exported by RPFM-CLI
///
/// This parser reads .loc.tsv files that have been exported from Total War
/// .pack files using RPFM-CLI's `--tables-as-tsv` option.
///
/// The TSV format is much more reliable than parsing the binary .loc format,
/// as it's generated by the official RPFM tool used by the Total War modding community.
class TsvLocalizationParser implements ILocalizationParser {
  @override
  Future<Result<LocalizationFile, FileServiceException>> parseFile({
    required String filePath,
    String encoding = 'utf-8',
    String? languageCode,
  }) async {
    return await _parseInternal(filePath, languageCode);
  }

  /// Internal parse method for TSV localization files
  ///
  /// Expected format:
  /// - Line 1: Headers (key\ttext\ttooltip)
  /// - Line 2: Metadata line starting with # (ignored)
  /// - Line 3+: Data rows (key\ttext\ttooltip)
  ///
  /// Returns [Ok] with parsed LocalizationFile or [Err] with exception
  Future<Result<LocalizationFile, FileServiceException>> _parseInternal(
    String filePath,
    String? languageCodeOverride,
  ) async {
    try {
      final file = io.File(filePath);

      if (!await file.exists()) {
        return Err(FileNotFoundException(
          'TSV file not found',
          filePath,
        ));
      }

      final lines = await file.readAsLines();

      if (lines.isEmpty) {
        return Err(FileParsingException(
          'TSV file is empty',
          filePath,
        ));
      }

      // Skip header line
      int startIndex = 1;

      // Skip metadata line if it starts with #
      if (lines.length > 1 && lines[1].startsWith('#')) {
        startIndex = 2;
      }

      final entries = <LocalizationEntry>[];

      for (int i = startIndex; i < lines.length; i++) {
        final line = lines[i].trim();

        // Skip empty lines
        if (line.isEmpty) continue;

        // Split by tab
        final parts = line.split('\t');

        // We need at least key and text columns
        if (parts.length < 2) {
          continue; // Skip malformed lines
        }

        final key = parts[0].trim();
        final text = parts[1].trim();

        // Skip if key or text is empty
        if (key.isEmpty || text.isEmpty) continue;

        // Skip if text is just "false" (tooltip placeholder)
        if (text == 'false') continue;

        final entry = LocalizationEntry(
          key: key,
          value: text,
          lineNumber: i + 1, // 1-indexed for user display
        );

        entries.add(entry);
      }

      // Extract file name and language from path
      final fileName = file.path.split(io.Platform.pathSeparator).last;
      final fileNameWithoutExt = fileName.replaceAll('.loc.tsv', '').replaceAll('.tsv', '');

      // Use override if provided, otherwise try to extract from filename
      String languageCode = languageCodeOverride ?? 'en';
      if (languageCodeOverride == null) {
        final langPattern = RegExp(r'_([a-z]{2})(?:\.loc)?$');
        final match = langPattern.firstMatch(fileNameWithoutExt);
        if (match != null) {
          languageCode = match.group(1)!;
        }
      }

      final locFile = LocalizationFile(
        fileName: fileNameWithoutExt,
        filePath: filePath,
        languageCode: languageCode,
        entries: entries,
        encoding: 'UTF-8',
        comments: [],
      );

      return Ok(locFile);
    } on io.FileSystemException catch (e) {
      return Err(FileNotFoundException(
        'Failed to read TSV file: ${e.message}',
        filePath,
        error: e,
        stackTrace: StackTrace.current,
      ));
    } catch (e, stackTrace) {
      return Err(FileParsingException(
        'Failed to parse TSV file: $e',
        filePath,
        error: e,
        stackTrace: stackTrace,
      ));
    }
  }

  @override
  Future<Result<LocalizationFile, FileParsingException>> parseString({
    required String content,
    required String fileName,
    required String languageCode,
  }) async {
    // Not implemented for TSV parser - TSV files must be parsed from disk
    return Err(FileParsingException(
      'parseString() not supported for TSV parser',
      fileName,
    ));
  }

  @override
  Stream<Result<LocalizationEntry, FileParsingException>> parseFileStream({
    required String filePath,
    String encoding = 'utf-8',
    String? languageCode,
  }) {
    // Not implemented for TSV parser
    throw UnimplementedError('parseFileStream() not supported for TSV parser');
  }

  @override
  Future<Result<String, FileServiceException>> generateFileContent({
    required LocalizationFile file,
    bool includeComments = true,
    bool applyPrefix = true,
  }) async {
    // Not implemented for TSV parser - we only read TSV, not generate
    return Err(FileWriteException(
      'generateFileContent() not supported for TSV parser',
      file.filePath,
    ));
  }

  @override
  Future<Result<String, FileServiceException>> writeFile({
    required LocalizationFile file,
    required String destinationPath,
    String encoding = 'utf-8',
    bool applyPrefix = true,
  }) async {
    // Not implemented for TSV parser - we only read TSV, not write
    return Err(FileWriteException(
      'writeFile() not supported for TSV parser',
      destinationPath,
    ));
  }

  @override
  Future<Result<FileValidationResult, FileServiceException>> validateFile({
    required String filePath,
  }) async {
    // Simple validation: check if file exists and has .tsv extension
    try {
      final file = io.File(filePath);
      if (!await file.exists()) {
        return Err(FileNotFoundException(
          'File not found',
          filePath,
        ));
      }

      if (!filePath.toLowerCase().endsWith('.tsv')) {
        return Ok(FileValidationResult(
          isValid: false,
          errors: ['File must have .tsv extension'],
          warnings: [],
        ));
      }

      return Ok(FileValidationResult(
        isValid: true,
        errors: [],
        warnings: [],
      ));
    } catch (e, stackTrace) {
      return Err(FileServiceException(
        'Validation failed: $e',
        error: e,
        stackTrace: stackTrace,
      ));
    }
  }

  @override
  Future<Result<String, FileEncodingException>> detectEncoding({
    required String filePath,
  }) async {
    // TSV files exported by RPFM are always UTF-8
    return const Ok('utf-8');
  }

  @override
  String? extractLanguageCode(String fileName) {
    final langPattern = RegExp(r'_([a-z]{2})(?:\.loc)?$');
    final match = langPattern.firstMatch(fileName);
    return match?.group(1);
  }

  @override
  String generatePrefixedFileName(String baseName, String languageCode) {
    // Not needed for TSV parser
    return '!!!!!!!!!!_${languageCode.toUpperCase()}_$baseName';
  }

  @override
  Future<Result<LocalizationFile, FileServiceException>> mergeFiles({
    required List<LocalizationFile> files,
    String conflictResolution = 'last',
  }) async {
    // Not implemented for TSV parser
    return Err(FileServiceException(
      'mergeFiles() not supported for TSV parser',
    ));
  }

  @override
  Future<Result<List<LocalizationFile>, FileServiceException>> splitFile({
    required LocalizationFile file,
    int maxEntriesPerFile = 10000,
  }) async {
    // Not implemented for TSV parser
    return Err(FileServiceException(
      'splitFile() not supported for TSV parser',
    ));
  }
}
